# Licensed under the BSD license.  See full license in LICENSE file.
# http://www.lightshowpi.com/
#
# This is the configuration file for the program. This file follows conventions
# of a python config file. The variables defined below control variable aspects
# of the program.
#
# Author: Chris Usey (chris.usey@gmail.com)
# Author: Todd Giles (todd.giles@gmail.com)
#
# Copy this sample file and rename as 'overrides.cfg' in this directory and then
# modify any and all settings that you need to or would like to.  You can also
# override settings via adding a file '/home/pi/.lights.cfg'.
#
# The order in which settings are loaded / overridden are:
#
#   (1) config/defaults.cfg (i.e. this file)
#   (2) config/overrides.cfg
#   (3) /home/pi/.lights.cfg
#   (4) ~/.lights.cfg (if not same as 3)
#
# A sample playlist is included to get you started and is distributed under a 
# creative commons license:
#
# http://freemusicarchive.org/music/Various_Artists_Rushcoil/XMAS_Compilation_2010
# XMAS Compilation 2010 - http://rushcoil.bandcamp.com/album/xmas-compilation-2010
# Various Artists: (Rushcoil)
# License: http://creativecommons.org/licenses/by-nc-sa/4.0


[hardware]
# Devices
#
# A user can define certain IC's to use with their project. A list of supported IC's
# are listed below along with their required parameters. You can define multiple IC's
# of the same type if you are chaining IC's or you can define multiple different types
# of IC's.  Some sample configurations can be found in the "config/contrib" directory.
# The support for these IC follow closely to extension supported by the wiringpi library.
# For more information regarding the extensions please visit the wiringpi extensions page.
# http://wiringpi.com/extensions/
#
# A NOTE ON PORT EXPANDERS 
# If you are using a port expander and enable them in the following settings
# you must enable i2c and/or spi modules on the raspberryPi. 
# you can check to see if these modules are enabled by issuing the command:
# $ sudo lsmod
# In the output you will find the following if i2c and/or spi is enabled
# > spi_bcm2708             4808  0 
# > i2c_bcm2708             4719  0 
# A simple Google search will provide instruction on enabling I2C and SPI modules 
# on the RaspberryPi
#
# Supported Devices:
#
#   IC NAME     |          IC TYPE                  |       ATTRIBUTES
# ______________________________________________________________________________
#  mcp23016     |   I2C Expansion Chip (16 Pins)    |   (pinBase, i2cAddress)
#  mcp23008     |   I2C Expansion Chip (08 Pins)    |   (pinBase, i2cAddress)
#  mcp23017     |   I2C Expansion Chip (16 Pins)    |   (pinBase, i2cAddress)
#  pcf8574      |   I2C Expansion Chip (8 Pins)     |   (pinBase, i2cAddress)
#  mcp23s08     |   SPI Expansion Chip (08 Pins)    |   (pinBase, spiPort, devId)	
#  mcp23s17     |   SPI Expansion Chip (16 Pins)    |   (pinBase, spiPort, devId)
#  sr595        |   Shift Register Chip (8 pins)    |   (pinBase, numPins, dataPin, clockPin, latchPin)
#
# The device setting is defined as a JSON formatted object. 
# If defining the object on more than one line, pay attention to spacing and tabs as 
# the object should follow python conventions for indentation.  If you get an error, chances are your 
# object is not formatted correctly or your indentation is not correct. You can check if your JSON is
# valid by using an online validator such as http://jsonlint.com.
#
# The Syntax is:
#
# devices = {
#		"< IC 1 Name >": [
#			{
#				"< IC 1 slave 1 attribute 1 name >": "< IC 1 slave 1 attribute 1 property >",
#				"< IC 1 slave 1 attribute 2 name >": "< IC 1 slave 1 attribute 2 property >"
#			},
#			{
#				"< IC 1 slave 2 attribute 1 name >": "< IC 1 slave 2 attribute 1 property >",
#				"< IC 1 slave 2 attribute 2 name >": "< IC 1 slave 2 attribute 2 property >"
#			}
#		],
#		"< IC 2 Name >": [
#			{
#				"< IC 2 slave 1 attribute 1 name >": "< IC 2 slave 1 attribute 1 property >",
#				"< IC 2 slave 1 attribute 2 name >": "< IC 2 slave 1 attribute 2 property >"
#			}
#		]
#	}
#
# By default no devices are defined
devices = {}

# If using a relay that is active low, set to 'yes'
active_low_mode = no

# GPIO pins to use for each channel
#
# Note!! The GPIO pins are numbered based on the wiringpi specification, not the official pi pinout.
# To find the physical pin locations and numbers, run the following command:
# gpio readall
# The 'Name' column will list the GPIO numbers that lightshowPi recognizes, and the 'Physical' column
# shows the physical location of that pin.
# Reference: http://wiringpi.com/pins/
#
# Using 8 pins of GPIO on the pi as well as 16 pins via  the MCP23017 OR MCP23S17 port
# expander with pin_base = 65:
#gpio_pins = 0,1,2,3,4,5,6,7,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80
#
# using additional GPIO of the pi B+ as well as the 16 pins via  the MCP23017 port
#gpio_pins = 0,1,2,3,4,5,6,7,21,22,23,24,25,26,27,28,29,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80
#
# Using 8 pins of GPIO on the pi:
gpio_pins = 0,1,2,3,4,5,6,7

# Using 8 pins of GPIO with FM transmitting on the pi b+:
#pin 7 cannot be used in FM mode because that is used for the antenna
#gpio_pins = 0,1,2,3,4,5,6,21

# Set the mode the pins should be configured in, namely "pwm" for fading in and
# out based upon the frequency response, or "onoff" for an on off switching
# effect when crossing a median frequency response per channel.

#
# Note: Mechanical relays will likely fail much sooner in "pwm" mode, it is 
# suggested to only use pwm mode if using solid state relays (SSR).
#
# You can configure each pin individually, for example:
#pin_modes = onoff,onoff,pwm,pwm,pwm,onoff,onoff
#
# Or you can simply set all pins to the same mode:
pin_modes = onoff

# We use the wiringPi's software pwm library for "pwm" fading:
#
# https://projects.drogon.net/raspberry-pi/wiringpi/software-pwm-library/
#
# TODO(toddgiles): Add a page to the wiki with examples of different types of lights and
# relays and the effect produced for various PWM ranges.  The text below should be taken
# with a grain of salt as I have not been able to test as completely as I'd like to yet.
#
# Change the pwm range used for this software pwm by changing this setting.  The optimal 
# setting really depends on your hardware setup.  If you are using zero-cross relays and 
# driving an AC load then using a pwm range of 500 gives decent results (flickering
# effect for many led lights with input rectifiers, and a decent fade for incandescents).
# A range of 500 generates a 20Hz pwm frequency.
#
# If you have random cross relays that can shut-off / on at any time then going for a
# 60 Hz pwm frequency can be advantageous, although timing this to the actual zero crossings
# of the power line used will give the best fading effect - again with incandescent bulbs.
# A range of 167 approximately generates a 60Hz pwm frequency.
#
# If you are attempting to fade a DC led load then the default range of 100 which gives a
# 100Hz pwm frequency works fine.
pwm_range = 100


[lightshow]
# We support the following modes for running lightshows:
#
# Control the lightshow from an audio stream coming from a usb-audio dongle
# See https://bitbucket.org/togiles/lightshowpi/wiki/Audio-In%20Mode for
# more details on using audio-in mode.
#mode = audio-in

# Play song files on the RPi from the playlist as defined below, with
# the preshow defined before each song. (default)
mode = playlist

# ---------------------------------------------------------------
# 'audio-in' mode specific configurations for the lightshow
# ---------------------------------------------------------------

# The number of input channels, typically 1 or 2:
#   1 - mono / mic input
#   2 - stereo input
audio_in_channels = 1

# The rate at which to sample input from the usb dongle
audio_in_sample_rate = 48000

# The name of the input audio card to use, by default use the default system
# audio input device.  You can override this to another card by setting it to the
# name found from the audio_in_cards.py script (in tools directory).
audio_in_card = default

# ---------------------------------------------------------------
# 'playlist' mode specific configurations for the lightshow
# ---------------------------------------------------------------

# The playlist_path defines the path to the .playlist file.  The .playlist file 
# is a text file that contains a list of what songs should be included in the show 
# and is in the format:
# [songname1] <tab> [/full/path/to/song]
# [songname2] <tab> [/full/path/to/song]
# A sample of how this should be configured can be found in $SYNCHRONIZED_LIGHTS_HOME/music/sample/
# To create your own playlist simply create a .playlist file with the songs desired and set the
# playlist_path accordingly.
#
playlist_path = $SYNCHRONIZED_LIGHTS_HOME/music/sample/.playlist

# Set the following setting to 'yes' to randomize playback of songs from the
# playlist.  Default is to play the songs in the order listed in the playlist.
randomize_playlist = no

# [DEPRECATED (preshow)]  - Please use preshow_configuration
# -----------------------------------------------------------
# Control the lights between songs.  You can turn the lights on and off a
# specified number of seconds an arbitrary number of times with the preshow
# setting.  If no preshow is defined, songs will be played one after another
# without any delay.  The syntax is:
#
# preshow = [off|on]:[seconds],[off|on]:[seconds],...
#
# Turn the lights off for 1 second, then on for 30, and then off for 1 second:
#preshow = off:1,on:30,off:1
#
# Turn the lights on for 30 seoncds, then off for 30 seconds:
#preshow = on:30,off:30
#
# Disable the preshow altogether:
#preshow =
#
# Default is to be on for 30 seconds, then off for 1:
# preshow = on:30,off:1
# ---------------------------------------------------------------

# Control the lights between songs.  You can turn the lights on and off a
# specified number of seconds an arbitrary number of times with the preshow_configuration
# setting.  If no preshow_configuration is defined, songs will be played one after another
# without any delay.  Individual channels can be controlled per transition defined by adding
# the channel_control option. The transition type will specify if all lights should be turned on,
# or turned off, and the channel_control will override the transition type so that specific channels
# can be controlled regardless of the transition type. Channels defined in the channel_control list
# are 1 based (i.e. the first channel starts at 1)  The preshow_configuration is defined as a JSON
# formatted object. If defining the object on more than one line, pay attention to spacing and tabs as 
# the object should follow python conventions for indentation.  If you get an error, chances are your 
# object is not formatted correctly or your indentation is not correct. You can check if your JSON is
# valid by using an online validator such as http://jsonlint.com.
#
# SPECIAL NOTE: Defining a channel_control WILL supercede any channels that are defined in always_on_channels
# or always_off_channels below. 
#
#The syntax is:
#preshow_configuration = 
#	{
#		"transitions": [
#			{
#				"type": "< off|on >",
#				"duration": < seconds >,
#				"channel_control": {
#					"< off|on >": [< channel >,< channel >,....]
#				}
#			},
#			{
#				"type": "< off|on >",
#				"duration": < seconds >,
#				"channel_control": {
#					"< off|on >": [< channel >,< channel >,....]
#				}
#			}
#		]
#	}
#
# Turn the lights on for 30 seconds, leaving channel 3 off during the "on" transition, then
# turn the lights off for 5 seconds, leaving channel 1 and 3 on during the "off" transition
#preshow_configuration = 
#	{
#		"transitions": [
#			{
#				"type": "on",
#				"duration": 30,
#				"channel_control": {
#					"off": [3]
#				}
#			},
#			{
#				"type": "off",
#				"duration": 5,
#				"channel_control": {
#					"on": [1,3]
#				}
#			}
#		]
#	}

# Disable the preshow altogether
#preshow_configuration =  {"transitions":}

# Default is to be on for 30 seconds and off for 1 with no channel_control override
preshow_configuration = 
	{
		"transitions": [
			{
				"type": "on",
				"duration": 10,
				"channel_control": {
				}
			},
			{
				"type": "off",
				"duration": 1,
				"channel_control": {
				}
			}
		]
	}

# --------------------------------------------------------------
# common lightshow configuration options (affects multiple modes)
# ---------------------------------------------------------------

# Override channels to be always on, always off, or inverted. inverted channels
# will turn off when music is played, and on otherwise.  These lists are 1
# based (i.e. the first channel starts at 1).
#
# SPECIAL NOTE: Defining an always on channel DOES NOT supersede any channels that are defined
# in the channel_control options of the preshow_configuration
#
# Always keep channels 2 and 6 on:
#always_on_channels = 2,6
#
# Always keep channel 5 off:
#always_off_channels = 5
#
# Invert the output for channel 4 and 8:
#invert_channels = 4,8
#
# Default (-1) disables each of these settings
always_on_channels = -1
always_off_channels = -1
invert_channels = -1


[audio_processing]
#By setting fm to true it will output the fm single on port 
#frequency is the fm channel to play on
fm = false
frequency = 100.

# Note: You may have to delete the song cache after changing these settings.

# The following values control the frequencies to which the channels will
# respond. With min_frequency being the lowest frequency for which a channel
# will be activated and max_frequency being the max frequency for which a 
# channel will be activated.
#
# The frequency range will be evenly divided beween all the channels defined
# in gpio_pins. 
#
# Note that custom_channel_frequencies overrides these settings.
min_frequency = 20
max_frequency = 15000

# The following setting can be used to custom map the channels, in effect
# this can programatically allow you to switch a specific channel of
# lights to a different frequency without having to physically rewire the
# channels.
#
# For example: Imagine we have 8 channel's output that are connected to
# corresponding gpio_pins. When the frequencies are mapped without using
# custom_channel_mapping, and with a channel mapping defined as:
#custom_channel_mapping = 1,2,3,4,5,6,7,8
# the lowest frequency is assigned to channel 1, the next highest to channel
# 2, and so on until the highest value is mapped to channel 8 (the 8th pin
# defined in gpio_pins).
#
# Now say you wanted your THIRD channel to have the lowest frequency, without
# using custom_channel_mapping you would have to physically rewire channel 3.
# With custom channel mapping you simply define:
#custom_channel_mapping = 1,2,1,4,5,6,7,8
# Now both channel 1 and channel 3 will activated when the lowest frequency is
# played. custom_channel_mapping must be the same size as gpio_pins.
#
# If you want to create a mirroring effect for the lights define:
#custom_channel_mapping = 1,2,3,4,4,3,2,1
# With custom channel mapping the program will only calculate and distribute
# frequencies for the highest channel listed in custom_channel_mapping. So in
# this mirroring example, the program will evenly distribute the frequencies.
#
# The default is not to define custom channel mapping and let the program
# map the channels 1:1
# custom_channel_mapping = 
custom_channel_mapping = -1

# Defining custom_channel_frequencies overrides the min_frequency and
# max_frequency settings, allowing you to define a custom list of frequencies
# that should be utilized for each channel. The list must be the size of
# (gpio_pins + 1) or if custom_channel_mapping is being used it must be the
# size of the max value + 1 in the custom_channel_mapping list.
#custom_channel_frequencies = 0,156,313,625,1250,2500,5000,10000,15000
# Raspberry Pi Model B+
#custom_channel_frequencies = 0,833,1666,2499,3332,4165,4998,5831,6664,7497,8330,9163,10829,11662,12495,13328,14161,15000
custom_channel_frequencies = -1

[webui]
# Specify the port number to use with the webui
# The default is 8080
webui_port = 8080
